---
title: "Completed Exercises from Hands-On Programming with R"
author: "Gavin McNicol"
date: "1/22/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

$~$

## Introduction

### Acknowledgement

These are the completed exercises for the 10 chapters of *Hands-On Programming with R* authored by Garrett Grolemund. The full text is freely available at <https://rstudio-education.github.io/hopr>.

### Purpose

Although the online version of the textbook includes most of the solutions, they are embedded within all the other material. I therefore created this set of completed exercises  to:

 - **provide a concise template of completed solutions for the coding exercises**
 
But also, to:

 - **practice using pulling and pushing to Github repositories**
 - **gain experience with RMarkdown syntax**

### Getting Started with R

Although I highly recommend the use of [RStudio Cloud](https://rstudio.cloud/), the textbook *Hands-On Programming with R* also features a handy [Appendix](https://rstudio-education.github.io/hopr/starting.html) to guide you through setting up R and RStudio IDE (Integrated Development Environment) on your local computer. 

$~$

## Chapter 1: The Very Basics

In this chapter we will cover:

 - Objects
 - Functions
 - Sampling with and without replacement
 - Writing your own functions
 - Function arguments
 - Extracting a function in RStudio

### Objects

You can assign an object a name and a value as follows

```{r}
# use <- to assign the value of 1 to the object 'a'
a <- 1
# then test it
a + 2
# the output of the expression evaluated (a + 2) is displayed in the box above
# note the use of the pound sign (#) at the start of a line lets me annotate the code
```

```{r}
# create an object, die, that is a sequence of numbers from 1 to 6, using ':'
die <- 1:6
die
```

R also understands capitalization in object names:

```{r}
Name <- 1
name <- 0

name + 1
```

R overwrites previous information without asking permission:

```{r}
my_number <- 1
my_number

my_number <- 999
my_number
```

Look at all the objects you have created using `ls()`:
```{r}
ls()
```

You can clear all your work space objects using (remove the # first)

```{r}
# rm(list=ls())
```


You can do all sorts of math with die (a sequence of numeric integers)

```{r}
die - 1
die / 2
die * die
```

When you multiply two vectors of unequal length, R will repeat the shorter vector to match the long vector (known as 'vector recycling')

```{r}
die + 1:2
```


But it will produce an error when the longer objeect is not a multiple of the shorter object

```{r}
die + 1:4
```

You can also do matrix multiplication

```{r}
die %*% die # inner
die %o% die # outer
```

### Functions

To use a function, just write the name of the function and then the data you want to operate on in the parentheses:

```{r}
round(3.1415)
factorial(3)
```

The data you pass the function is called the function's **argument**. The argument can be:

```{r}
mean(1:6) # raw data
mean(die) # an R object
round(mean(die)) # of even the result of another function
```

You can "roll" the dice using the sample function, with arguments `x` (vector/data) and `size` (number of elements to sample):

```{r}
sample(x = 1:6, size = 2)
```

Roll your die by setting x to `die` and sample 1 number from it:

```{r}
sample(x = die, size = 1)

```

Roll it again:

```{r}
sample(x = die, size = 1)
```

R doesn't require arguments to be named, for example:

```{r}
sample(die, 1)
```

And if you use the wrong argument names, you will get an error:

```{r}
# round(3.1415, corners = 2) # running this without the # sign will cause an error
# this is because the function round() does not use the argument 'corners'
```

You can look up the function's arguments with `args`:

```{r}
args(round) 
# the output shows that the digits argument has a default value of zero, which rounds to the nearest integer
```

You can change the default value by assigning a new value to the digits argument:

```{r}
round(3.1415, digits = 2)
```

If you do not write argument names (which is recommended for any arguments after the first 2) then R matches values using the order:

```{r}
sample(die, 1) # here, R automatically matches the value 1 to the argument 'size'
```

If you name all your arguments, R doesn't care if you enter them in the non-standard order:

```{r}
sample(size = 1, x = die) 
```

### Sample with replacement

By setting the argument size to 2, we can almost simulate the rolling of a pair of dice:

```{r}
sample(die, size = 2)
```

*Almost* like two dice, because if you repeat it many times, you will see that it never selects the same number twice:
```{r}
sample(die, size = 2) 
sample(die, size = 2)  
sample(die, size = 2)  
```

In other words, it samples *without* replacement.

We need to sample *with* replacement, using the argument `replace = TRUE`:

```{r}
sample(die, size = 2, replace = TRUE) 
```

Sampling with replacement is an easy way to create independent random samples.

**Congratulations, you can now simulate rolling a pair of dice!**

You can also add up the result of your simulated dice throw if you save the output to the object `dice`, then use the function `sum()` on dice:

```{r}
dice <- sample(die, size = 2, replace = TRUE)
dice
sum(dice)
```

Confirm that calling dice won't rerun `sample(die, 2, replace = TRUE)`:

```{r}
dice
dice # it gives the same result as originally output 
```

However, you *can* create an object that will re-roll the dice whenever you call it. In R, these are called **Functions**.

### Writing your own functions

We will write a function `roll()`, that will return the sum of rolling two dice:

```{r}
roll <- function() { # this line contains the function name (roll) and the parentheses contain the argument (here, there are none)
  die <- 1:6
  dice <- sample(die, size = 2, replace = TRUE)
  sum(dice) # these three lines within the pair of braces contain the function's body of code. The indentations are only for clarity.
}
```

R returns the last line of the body of code within the function, so make sure the final line of code returns a value:

```{r}
roll()
```

For instance, these lines of code as the final line will return a value:

```{r}
dice
1 + 1
sqrt(2)
```

But these lines will not:

```{r}
dice <- sample(die, size = 2, replace = TRUE)
two <- 1 + 1
a <- sqrt(2)
```

### Arguments

What would happen if we changed our `roll()` function to this?

```{r}
# roll2 <- function() {
#   dice <- sample(bones, size = 2, replace = TRUE)
#   sum(dice)
# }
# 
# roll2()
```

If you remove the # signs, it produces an error because the object `bones` cannot be found by the function.

To supply `bones`, put the object name bones as an argument in the parentheses that follow the function:

```{r}
roll2 <- function(bones) {
  dice <- sample(bones, size = 2, replace = TRUE)
  sum(dice)
}
```

Now `roll2()` will work as long as you provide a value or values for `bones` each time you call it:

```{r}
roll2(bones = 1:6)
```

Because there is only one argument, `bones`, we do not need to name it for R to match the values:

```{r}
roll2(1:6)
```

roll2() will still give an error if you do not supply `bones` at all. You can prevent this by assigning a default value when writing the function:

```{r}
roll2 <- function(bones = 1:6) {
  dice <- sample(bones, size = 2, replace = TRUE)
  sum(dice)
}
```

```{r}
roll2()
```

You can give your functions as many arguments as you like, just list their names, separated by a comma.

### Extract Function in RStudio

If you are working in the script window of RStudio you can create a function from lines of code using the drop-down menu option **Code > Extract Function**.

Test it out with the three lines of code from the body of code in our `roll()` function:

```{r}
die <- 1:6
dice <- sample(die, size = 2, replace = TRUE)
sum(dice)
```

After you've done it, your code should update to look like this:

```{r}
roll <- function() {
  die <- 1:6
  dice <- sample(die, size = 2, replace = TRUE)
  sum(dice)
}
```

You should now have a familiarity with:

 - Objects
 - Functions
 - Sampling with and without replacement
 - Writing your own functions
 - Function arguments
 - Extracting a function in RStudio
 
**Great work, you've finished Chapter 1!**

$~$

## Chapter 2: Packages and Help Pages

In this chapter we will cover:

 - Installing a package
 - Loading a package from your library of packages
 - Plotting using the function `qplot` from the `ggplot` package
 - Using help pages

### Packages

Packages are collections of functions and objects made by professors, programmers, statisticians, and other R users.

We will try using the `qplot` function which comes from the *ggplot2* package, a popular package for making graphs.

First, install the package with the following function:

```{r}
# install.packages("ggplot2")
```

`qplot` won't work without loading it:

```{r}
# qplot
# will give an error if you remove the # sign
```

To load an installed package use:

```{r}
library("ggplot2")
```

And look at `qplot`:

```{r}
qplot
```

`qplot` makes "quick plots". Let's test it out by defining some x and y values:

```{r}
x <- c(-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1)
x
```

```{r}
y <- c(x^3)
y
```

```{r}
qplot(x, y)
```

Notice how R matches the order of values in the vector `x` with the order of values in vector `y`? 

This is known as *element-wise execution*.

We can also make a histogram by just providing one vector of values:

```{r}
x <- c(1, 2, 2, 2, 3, 3)
qplot(x, binwidth = 1)
```

The notation for describing this histogram intervals looks like: `[1, 2)`
The hard bracket `[` means the first number is included in the interval.
The parenthesis `)` means the last number is *not* included.

For example, in the histogram above, there are three values in the interval `[2, 3)`.

Let's try another example:

```{r}
x2 <- c(1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4)
qplot(x2, binwidth = 1)
```

And another:

```{r}
x3 <- c(0, 1, 1, 2, 2, 2, 3, 3, 4)
qplot(x3, binwidth = 1)
```

You can use a histogram to display visually how common different values of `x` are.

Let's try visualizing many the *replicated* output of `roll()` (many dice rolls):

```{r}
replicate(3, 1 + 1)
```

```{r}
rolls <- replicate(10, roll())
qplot(rolls, binwidth = 1)
```

To get a better sense of the long term  pattern, let's replicate it 10,000 times:

```{r}
rolls <- replicate(10000, roll())
qplot(rolls, binwidth = 1)
```

The histogram shows that the dice behaves predictably when replicated many times. The more likely values occur more frequently (e.g., 6, 7, and 8)


### Help Pages

Use a question mark `?` before a function name to open the help page:

```{r}
?sqrt
?log10
?sample
```

The help page has several sections:

 - *Description*
 - *Usage*
 - *Arguments*
 - *Details*
 - *Value*
 - *See Also*
 - *Examples*
 
You can also search by keyword if you forget a function name:"

```{r}
??log
```

Let's look at the `sample` help page:

```{r}
?sample
```

You'll have to copy and paste `?sample` into your RStudio console window, or run it from the script window.

Notice `prob`:

|   `A vector of probability weights for obtaining the elemtents of the vector being sampled.`

And Details has more information:
|   `The optional prob argument can be used to give a vector of weights for obtaining the elements of the vector being sampled. They need not sum to one, but they should be nonnegative and not all zero`

Re-write the `roll` function to roll a pair of weighted dice:

```{r}
roll <- function() {
  die <- 1:6
  dice <- sample(die, size = 2, replace = T, 
                 prob = c(rep(1/8, 5), 3/8))
  sum(dice)
}
```

Rerun the code chunk above, and then visualize the long term behavior of your dice:

```{r}
rolls <- replicate(10000, roll())
qplot(rolls, binwidth = 1)
```

Notice that after changing the `prob` vector to make 6 more common, the distribution of dice roll outcomes is now skewed.

You should now have a familiarity with:

 - Installing a package
 - Loading a package from your library of packages
 - Plotting using the function `qplot` from the `ggplot` package
 - Using help pages
 
**Great job, you've finished Chapter 2!**

$~$

## Chapter 3: R Objects

In this chapter we will cover:

 1. Objects
     + Atomic Vectors
     + Doubles
     + Integers
     + Characters
     + Logicals
     + Complex and Raw
 2. Attributes 
     + Names
     + Dim
 3. Matrices
 4. Arrays
 5. Class
     + Dates and Times
     + Factors
 6. Coercion
 7. Lists
 8. Data Frames
 9. Loading Data
 10. Saving Data

### Objects
#### Atomic Vectors

Create an atomic vector by grouping values with c (concatenate)

```{r}
die <- c(1, 2, 3, 4, 5, 6)
die
is.vector(die)
```

Vectors can be of just one value

```{r}
five <- 5
is.vector(five)
```

There are 6 types of atomic vectors in R:

 1. *Doubles* are the default for numbers and are the computer science term for numerics:

```{r}
typeof(die)
```


 2. *Integers* store numbers without decimal points. Adding an L after a numeric value creates an integer:
 
```{r}
int <- c(-1L, 2L, 4L)
int
typeof(int)
```

By default, integer numbers saved without the L will be saved as double.

Double values are accurate to about 16 significant digits. This rounding is normally negligible, but can create *floating-point errors* when rounding effects add up.

 3. *Character vectors* store small pieces of text:
 
```{r}
text <- c("Hello", "World")
text
typeof(text)
```

The individual elements of a character vector are known as strings. Can you tell the difference between a character string and a number?

```{r}
typeof(1)
typeof("1")
typeof("one")
```

Be careful, you can confuse R objects with strings, for example:

```{r}
x <- "x"
x
```

 4. *Logicals* are TRUE, FALSE, T, and F are R's version of logical (Boolean) data:
 
```{r}
logic <- c(TRUE, TRUE, FALSE)
logic
typeof(logic)
typeof(T)
```
 
 5. *Complex*. It is unlikely you will ever use these last two vector types but... for a complex vector, add an imaginary term to a number, with i:
 
```{r}
comp <- c(1 + 1i, 1 + 2i, 1 + 3i)
comp
typeof(comp)
```
 
 6. *Raw* vectors store raw bytes of data. A simple empty raw vector of length n can be made with:
 
```{r}
raw(3)
typeof(raw(3))
```

**Exercise**: What sort of vector will you use to store the face names of cards in a royal flush? ( i.e. "ace", "king", "queen", "jack", "ten )

```{r}
hand <- c("ace", "king", "queen", "jack", "ten")
hand
typeof(hand)
```

#### Attributes

You can build a more sophisticated objects vector from an atomic vector by giving it *attributes* and assigning a *class*.

An *attribute* is a piece of information you can attach to atomic vectors (or any R object). Normally, R will ignore this information, unless you ask to look for it

```{r}
attributes(die)
```

R uses NULL to represent an empty object.

*Names*, *dimensions* (*dim*), and *classes* are the most common attributes.

*Names*

```{r}
names(die)
names(die) <- c("one", "two", "three", "four", "five", "six")
names(die)
attributes(die)
```

Now die has the names attribute.

Names will be displayed above the object when you look at it:

```{r}
die
```


However they won't affect the values of the vector:

```{r}
die + 1
names(die) <- c("uno", "dos", "tres", "cuatro", "cinco", "seis")
die
```

To remove names, set it to NULL:

```{r}
names(die) <- NULL
```

*Dimensions*
You can transform an atomic vector into an n-dimensional array with dim:

```{r}
dim(die)
```

Transform it into a (2 row x 3 column) array:

```{r}
dim(die) <- c(2, 3)
die
```

Now into a (3 row x 2 column) array:

```{r}
dim(die) <- c(3, 2)
die    
```

Now into a (1 row x 2 column x 3 slice) hypercube (a 3 dimensional structure):

```{r}
dim(die) <- c(1, 2, 3)
die
```

Two notes on dim

 * R will always use the first value of dim for the rows, and second for columns
 * R will always fill the array by columns (all rows in column 1 first, and so on

*Matrices* store two-dimensional arrays. A matrix will organize your vector of values into a matrix with the specified number of rows:

```{r}
m <- matrix(die, nrow = 2)
m
```

To fill by row (rather than default by column):

```{r}
m <- matrix(die, nrow = 2, byrow = TRUE)
m
```

More customization is possible, remember to check the help page with:

```{r}
?matrix
```

*Arrays* create an n-dimensional array, for example a hypercube in 4, 5, or n dimensions:

```{r}
ar <- array(c(11:14, 21:24, 31:34), dim = c(2, 2, 3))
ar
```

**Exercise**: Create a 5 x 2 matrix for a royal flush of spades. (Remember the hand object created earlier)

```{r}
hand1 <- c(hand, "spades", "spades", "spades", "spades", "spades")

matrix(hand1, nrow = 5)
matrix(hand1 , ncol = 2)
dim(hand1) <- c(5, 2)
hand1
```

Notice that all three of these options for arranging the array dimensions work.

#### Class
Notice that changing `dim` doesn't change the type, but does change the class:

```{r}
dim(die) <- c(2, 3)
typeof(die)
class(die)
```

A class is a special case of an atomic vector. After using dim, die is now a matrix (class), a special case of a double atomic vector. The class attribute may not always appear if you run attributes:

```{r}
attributes(die)
```

Even if a class attribute is not assigned, R will return one based on the atomic vector type:

```{r}
class("Hello")
class(5)
```

Setting an object's class attribute is normally a bad idea. Discussed more in Part 3 of the book!

#### Dates and Times

Attributes let R represent more types of data than just doubles, integers, characters, etc.
R uses the "POSIXct" and "POSIXt" classes for dates and times:

```{r}
Sys.time() # a function to return the current time on your computer
now <- Sys.time()
now
```

It looks like  a character string, but it's data type is actually double:

```{r}
typeof(now)
class(now)
```

In POSIXct, a widely used framework, any date and time is represented by the number of seconds before or after the standard date and time:

E.g., 12:00 AM January 1st 1970 (in the Universal Time Coordinated (UTC) zone)

Check using the unclasss function:

```{r}
unclass(now)
```

Check what day it was a million seconds after the standard date and time:

```{r}
mil <- 1000000
mil
```

And look at the class:

```{r}
class(mil) <- c("POSIXct", "POSIXt")
mil
```

This worked well, but in general forcing a class on an object is not a good idea. Classes are normally interpreted by R based upon the value type in the object.

#### Factors
Factors are how R stores categorical information, like eye color or ethnicity. To make a factor, pass an atomic vector to the factor function:

```{r}
gender <- factor(c("male", "female", "female", "male"))
gender
typeof(gender)
```

Notice that R stores the factor as type integer, this is because it assigns factors levels:

```{r}
attributes(gender)
```

You can see exactly how R is storing your factor with unclass:

```{r}
unclass(gender)
```

Factors can be confusing because they look like characters but behave like integers. 

R will often try to convert character strings to factors when you load and create data but how to avoid this will be covered later.

```{r}
as.character(gender)
```

Congrats! You now understand all the possibilities of R's atomic vectors!

#### Coercion

Try creating an atomic vector with two value types:

```{r}
card <- c("ace", "hearts", 1)
card
```

Notice the integer 1, is now a character string? R has *coerced* it into a character string because atomic vectors, and their special cases, matrices and arrays, can only store ONE type of data:

**Coercion rules**:

If a character string is present, R coerces everything to character strings:

```{r}
c(1, 2, 3, "4")
```

If logicals and numbers, R coerces everything to numbers (T = 1, F = 0):

```{r}
c(TRUE, 5, 5, FALSE)
```

If you try to do math with logical values, it will count the number of TRUEs:

```{r}
sum(c(TRUE, TRUE, FALSE, FALSE))
```

To explicitly convert between data types:

```{r}
as.character(1)
as.logical(1)
as.numeric(FALSE)
```

#### Lists

To completely avoid coercion, you can use lists:

```{r}
list1 <- list(100:130, "R", list(TRUE, FALSE))
list1
```

The double bracket index tells you which element of the list is displayed:

```{r}
list1[[2]]
```

The single bracket tells you which subselement of the list is displayed:

```{r}
list1[[1]][3]
```

This distinction is important because a list object can be anything, including another list:

```{r}
list1[[3]]

# Is composed of...

list1[[3]][[1]]
list1[[3]][[2]]
```

Use a list to store a single playing card, such as the ace of hearts, worth one point:

```{r}
card <- list("ace", "hearts", 1)
card
```

You could use lists to create a list, with 52 sublists, for all the differen cards but there is a faster way!

#### Data Frames

Data frames are the two-dimensional version of a list and by FAR the most useful storage structure for data analysis, and perfect for a deck of cards. (You can think of a data frame as the equivalent of an Excel spreadsheet)

Give the data.frame() function any number of vectors, separated by a comma. Each vector should be set equal to a name that describes the vector:

```{r}
df <- data.frame(face = c("ace", "two", "six"),
                 suit = c("clubs", "clubs", "clubs"),
                 value = c(1, 2, 3))
df
```

Note that df columns have to be of the same length. A data.frame is of special case of a list, of class "data frame":

```{r}
typeof(df)
class(df)
```

The `str` function shows you which and how objects are grouped together:

```{r}
str(df)
```

Notice R saved the strings as factor, you can suppress this with:

```{r}
df <- data.frame(face = c("ace", "two", "six"),
                 suit = c("clubs", "clubs", "clubs"),
                 value = c(1, 2, 3), 
                 stringsAsFactors = FALSE)
str(df)
```

We could not type out all 52 card combinations, but it is easier to load data and safer for your data, and wrists.

#### Loading Data

Plain text files are the typical data storage type in R (and other data sci. applications).

Go to http://bit.ly/deck_CSV to download the card deck file and take a look inside the .csv file.

Go to the top-left window: Environment > Import Data > From Text File... > Select deck.csv > Open > Import.

Look at the top and bottom of the data frame with:

```{r}
deck <- read.csv("deck.csv") # this line is required if you don't import through the menu buttons
head(deck)
tail(deck)
```

Bbefore continuing, let's save a new copy of the deck.csv. To find out where it saved it, check the working directory.

```{r}
wd <- getwd()
setwd(wd)
```

```{r}
write.csv(deck, file = "cards.csv", row.names = FALSE)
```

Notice, write.csv() needs three arguments: 

 1. The name of the object you wish to save
 2. The name you should give to the file you wish to save
 3. You should stop R from adding a column of numbers using `row.names = FALSE`

Notes on loading data:

 * R can open non-csv files, like Excel (xlsx) files directly
 * But it's good practice to open data in the original program first
 * Then export the data in a csv file type
 * The exception of course being if you don't have the software (and its expensive!)

You should now have a familiarity with:

 - Objects
 - Attributes
 - Class
 - Coercion
 - Lists
 - Data Frames
 - Loading/Saving Data
 
**Great job, you've finished Chapter 3!**

$~$

## Chapter 4: R Notation

In this chapter we will cover:

 1. Selecting Values
     + Positive Integers
     + Negative Integers
     + Zero
     + Blank Spaces
     + Logical Values
     + Names
 2. Deal a Card
 3. Shuffle the Deck
 4. Dollar Signs and Double Brackets

### Selecting Values

To extract a value or set of values from a data frame use a pair of hard brackets:

```{r}
deck[,]
```

There are six ways to write an index in R, each is useful. 

 - Positive integers
 - Negative integers
 - Zero
 - Blank spaces
 - Logical values
 - Names

*Positive Integers* work like *i,j* notation in algebra. 

`Deck[i,j]` will return the ith row and the jth column:

```{r}
head(deck)
deck[1, 1]
```

Extract more than one value using a vector of positive integers:

```{r}
deck[1, c(1, 2, 3)]
deck[1, 1:3]
```

R doesn't remove these values, it gives you a new set which you can save to a new R object:

```{r}
new <- deck[1, 1:3]
new
```

You can therefore repeat values more than once, by repeating an index:

```{r}
deck[c(1, 1), c(1, 2, 3)]

```

R's notation system works for any R object, as long as you supply one index for each dimension:

```{r}
vec <- c(6, 1, 3, 6, 10, 5)
vec[1:3]
```

R's indexing begins at 1, as in algebra, and unlike zero for many other programming langauges. This means, given an index of 1, R returns the first element of an object.

 - If you only select a single column, R will return a vector rather than the dataframe column
 - If you would prefer the dataframe column is maintained, add drop = FALSE to the brackets
 
```{r}
deck[1:2, 1]
deck[1:2, 1, drop = F]
```
 
*Negative integers* return every element *except* the elements of a negative index. For example:

```{r}
deck[-(2:52), 1:3]
```

Returns the first row, and excludes every other row. Negative integers are therefore more efficient for removing just a few rows or columns. You can mix positive and negative integers, but *only* in different indexes (row vs. column):

```{r}
deck[-1, 1, drop = F]
```

*Zero* returns nothing from a dimension when you use it as an index, creating an empty object:

```{r}
deck[0, 0]
```

It's not very helpful as an index!

*Blank spaces* tell R to extract every value in a dimension (an entire row or column):

```{r}
deck[1, ]
deck[, 2, drop = F]
```

*Logical Values*: T/TRUE values are returned if you provide a vector of same dimension as the object:

```{r}
deck[1, c(T, T, F)]
rows <- c(T, rep(F, 51)) # rep calls the repeat function which takes a vector of values and # of repetitions as arguments
deck[rows, ]
```

Using logicals may seem a little odd, but it can become a powerful tool!

*Names* can be used to extract values based on their names in the object. Commonly used to extract particular named *columns*:

```{r}
deck[1, c("face", "suit", "value")]
deck[ ,"value"]
```


**Exercise**: Deal a Card!

Make a function that returns the first row of a data frame. Complete the basic function syntax:

```{r}
deal <- function(cards) {
  # insert your function here
}
```

Fill in the function:

```{r}
deal <- function(cards) {
  cards[1, ]
}
```

Try it out
```{r}
deal(deck)
```

Notice that it always deals the same (top) card:

```{r}
deal(deck)
```

This is a difficult problem to solve, so we will come back to it in Chapter 6.

For now, you can just shuffle the deck after every deal. This is not a perfect solution because the card you dealt first is still present. To shuffle, you want to rearrange the order of the cards in your deck, each row in the data frame is a card so you want to randomly reorder the rows:

Start by extracting every row in your data frame:

```{r}
deck2 <- deck[1:52, ]
```

The order is replicated exactly:

```{r}
head(deck2)
```

Alternatively, you can manually rearrange some of the rows:

```{r}
deck3 <- deck[c(2, 1, 3:52), ]
```

However, to randomized the order, you need to sort the integers (row numbers) into a random order. Then use the results as a row index. Use the `sample()` function for this:

```{r}
random <- sample(1:52, size = 52) # replace will be F by default
random
# creates a random index which you can use to subset from deck (below)
deck4 <- deck[random, ]
head(deck4)
```

Now the deck is truly shuffled! Combine with the deal function to create a shuffle function:

```{r}
shuffle <- function(cards){
  random <- sample(1:52, size = 52)
  cards[random, ]
}
```

You can now shuffle the card deck between each deal:

```{r}
deal(deck) # returns the top card of the deck
deck2 <- shuffle(deck) # randomly shuffles the deck and saves it as a new deck2 object
deal(deck2) # returns the top card of deck2
```

#### Dollar Signs and Double Brackets

You can also select a column from a data frame using the $:

```{r}
deck$value
```

Notice it will provide options to select from when you add $ to the data frame. This is very handy for computing means or other statistics:

```{r}
mean(deck$value)
median(deck$value)
```

$ can also be used to subset lists in efficient ways. First, confirm that subsetting a list using a regular index returns a list:

```{r}
lst <- list(numbers = c(1, 2), logical = TRUE, strings = c("a", "b", "c"))
lst
lst[1]
typeof(lst[1]) # notice the output is a list with one element
```

Most R functions do not work with lists: (remove # sign to run)

```{r}
#  sum(lst[1])
```

Use the $ notation instead to get the values with no list structure:

```{r}
lst$numbers
sum(lst$numbers)
```

Alternatively, if you don't have or don't want names, for your list elements, then use double hard brackets to index:

```{r}
lst[[1]]
lst[[2]]
```

Summary:

 - if you subset a list with single-bracket notation, R will return a smaller list
 - if you subset a list with double-bracket notation, R will return just the values inside that element of the list

You can combine the single or double brackets with any indexing method:

```{r}
lst["numbers"]
lst[["numbers"]]
```

You should now have a familiarity with:

 1. Selecting Values
     + Positive Integers
     + Negative Integers
     + Zero
     + Blank Spaces
     + Logical Values
     + Names
 2. Dollar Signs and Double Brackets
 
 3. And you know how to write a function to shuffle a card deck, and deal a card from a shuffled deck!

**Congrats! You have completed Chapter 4!**

$~$

## Chapter 5: Modifying Values

In this chapter we will cover:

 1. Changing Values in Place
 2. Logical Subsetting
      + Logical Tests
      + Boolean Operators
 3. Missing Information
      + na.rm
      + is.na
  
We will use these new skills to change the point system of the deck.

Make a copy of the deck so you can always reload the pristine version:

```{r}
deck2 <- deck
```

#### Changing Values in Place

Start by creating a simple vector of zeros:

```{r}
vec <- c(0, 0, 0, 0, 0, 0)
vec
```

Select the first value using hard brackets:

```{r}
vec[1]
```

Try modifying the first value with the assignment operator `<-` :

```{r}
vec[1] <- 1000
vec
```

You can replace multiple values, as long as the number of new values ==  number of selected values:

```{r}
vec[c(1, 3, 5)] <- c(1, 1, 1)
vec
```

Whereas this will not work: 

```{r}
vec[4:6] <- vec[4:6] + 1
vec
```

You can also create new values that do not exist yet, by expanding the object:

```{r}
vec[7] <- 0
vec
```

Try adding a new variable to your data set using `$`:

```{r}
deck2$new <- 1:52
deck2
```

Then try removing it with the symbol `NULL`:

```{r}
deck2$new <- NULL
```

Let's create a "War Deck", for which aces have the value, 14 rather than 1.

First, use R's notiation system to identify the aces:

```{r}
deck2[c(13, 26, 39, 52), ]
```

You can also single out just the value of the aces (in the 3rd column of deck2):

```{r}
deck2[c(13, 26, 39, 52), 3]
```

And do it more efficiently with a vector:

```{r}
deck2$value[c(13, 26, 39, 52)]
```

Now reassign the aces to 14:
*Hint*: You can use a vector of 14s, or just one 14 which R will recycle to all elements.

```{r}
deck2$value[c(13, 26, 39, 52)] 
deck2$value[c(13, 26, 39, 52)]
```

Notice the values change "in place".

```{r}
deck2
```

The same technique works for vectors, matrices, arrays, lists, and data frames!

In this example, we knew where the aces were but if the deck was shuffled, how would we know which values to reassign?

Shuffle the deck and save it as deck3:

```{r}
deck3 <- shuffle(deck)
deck3
```

Now the aces are hard to find!

#### Logical Subsetting

Logical subsettingcan be used to return elements that match a TRUE:

```{r}
vec
vec[c(F, F, F, F, T, F, F)]
```

However, you don't have to type out a long vector of T and F. Use a *Logical Test* using logical operators:
E.g.,use the operators:

 + `>` greater than
 + `>=` greater than or equal to
 + `<` less than
 + `<=` less than or equal to
 + `==` equal to
 + `!=` not equal to
 + `%in%` exists within the vector (this one is very handy!)

```{r}
1 > 2
1 > c(0, 1, 2)
c(1, 2, 3) == c(3, 2, 1)
```

Note: `%in%` does not use element-wise execution, it asks *are the values on the left are on the right side?*:

```{r}
1 %in% c(3, 4, 5)
c(1, 2) %in% c(3, 4, 5)
c(1, 2, 3) %in% c(3, 4, 5)
```

Remember: `=` is the same as the assignment operateor `<-` in R. Be careful to use `==` when you want to evaluate equivalence (is equal).

**Exercise:** Extract the face column of `deck2`, and test if it is equal to `ace`:

First convert desk faces to characters:
```{r}
deck2$face 
deck2$face <- as.character(deck2$face)
```

Now perform the *logical test*:

```{r}
deck2$face == "ace"
```

You can also count the number of TRUE (treated as 1):

```{r}
sum(deck2$face == "ace")
```

You can also use this on your shuffled `deck3`, to the same effect:

```{r}
deck3$face == "ace"
```

The logical operator now provides row *indices* to extract rows or individual elements:

```{r}
deck3$value[deck3$face == "ace"]
```

Now use the assignment as before to change the values of ace to 14:

```{r}
deck3$value[deck3$face == "ace"] <- 14
```

Check to see if aces now have value of 14:

```{r}
head(deck3, 20) 
```

They do!

Logical subsetting is a key component of vectorized programming, a coding style that lets you write fast and efficient R code. We come back to this in Chapter 10.

Let's adapt the deck for Hearts, where every card has a value of zero, except suit of hearts, which has a value of 1.

```{r}
deck4 <- deck
deck4$value <- 0
head(deck4, 13)
```

To assign 1 to every card in deck4 that has a suit of hearts, first find the hearts:

```{r}
deck4$suit == "hearts"
```

Check the subset is correct:

```{r}
deck4$value[deck4$suit == "hearts"]
```

Assign the new value of 1:

```{r}
deck4$value[deck4$suit == "hearts"] <- 1
deck4$value[deck4$suit == "hearts"]
```

Finally, change the queen of spades to value of 13. Let's find the queen of spades:

```{r}
deck4[deck4$face == "queen", ] 
deck4[deck$suit == "spades", ] 
```

We can't do it with this code! The first line gives all queens and the second line gives all spades. 

#### Boolean Operators

To identify just the queen of spades, we want to use *Boolean Opereators* (and `&`, or `|`) to combine Logical Tests together.

There are six Boolean operators:

 + `&` both conditions (and)
 + `|` one or other condition
 + `xor` exactly one condition
 + `!` false condition
 + `any` any conditions
 + `all` all conditions
 
Remember to include the complete test on both sides of the Boolean operator:

```{r}
x <- 5
x > 2 & x < 9
# x > 2 & < 9
```

If you remove the # sign, the last line gives an error when you try to run it because the test is incomplete on the right side.


Boolean opeartors follow the same element-wise execution:

```{r}
a <- c(1, 2, 3)
b <- c(1, 2, 3)
c <- c(1, 2, 4)
```

```{r}
a == b
b == c
a == b & b == c
```

Use Boolean operator to locate the queen of spades:

```{r}
deck4$face == "queen" & deck4$suit == "spades"
```

Note that we join the two logical tests with a Boolean operator.

Save the results to its own object to make it easier to work with:

```{r}
queenOfSpades <- deck4$face == "queen" & deck4$suit == "spades"
```

Make sure it works:

```{r}
deck4[queenOfSpades, ]
```

Now assign the new value:

```{r}
deck4$value[queenOfSpades] <- 13
```

Set up some new objects to try out more logical tests:

```{r}
w <- c(-1, 0, 1)
x <- c(5, 15)
y <- "February"
z <- c("Monday", "Tuesday", "Friday")
```

Is w positive?

```{r}
w > 0
```

Is x greater than 10 and less than 20?

```{r}
x > 10 & x < 20
```

Is object y the word February?

```{r}
y == "February"
```

Is every value in z a day of the week?

```{r}
all(z %in% c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"))
```


Finally, let's create a card deck to play Blackjack, where all face cards have a value of 10, and ace is either 1 or 11.

Start by creating a new deck:

```{r}
deck5 <- deck
head(deck5)
```

Change the value of face cards in none fell swoop with `%in%`.

First identify the indices:
```{r}
facecard <- deck5$face %in% c("king", "queen", "jack")
deck5[facecard, ]
```

Then conver the values: 

```{r}
deck5$value[facecard] 
deck5$value[facecard] <- 10
```

Check:

```{r}
head(deck5, 10)
```

Right now, we don't have enough information to assign the ace a value (it depends on the player's other cards)!


#### Missing Information
In R, `NA` stands for "Not Available" and is used as a placeholder for missing values. Because we do not know what `NA` is, it will propogate through any calculations:

```{r}
NA + 1 
```

Missing values `NA` help you maintain complete data structure rather than having gaps. However they also propogate to other compuations:

```{r}
mean(c(NA, 1:50))
```

Most R functions come with an optional argument, `na.rm`, which stands for `NA` remove. If `na.rm = TRUE`, it will ignore `NA`s:

```{r}
mean(c(NA, 1:50), na.rm = T)
```

Again, because we don't know what `NA` is, we also can't identify it using logical tests (remove # sign):

```{r}
# NA == NA
# c(1, 2, 3, NA) == NA 
```

But, R uses the function `is.na()` to identify if a value is an `NA`:

```{r}
is.na(NA)
```

Use `is.na()` to identify the index of `NA` in a data structure such as a vector:

```{r}
vec <- c(1, 2, 3, NA)
is.na(vec)
```

So, finally, set all ace values to `NA`, because we don't know the real value until the end of a players turn:

```{r}
deck5$value[deck5$face == "ace"] <- NA
head(deck5, 13)
```

You should now have a familiarity with:

 1. Changing Values in Place
 2. Logical Subsetting
      + Logical Tests
      + Boolean Operators
 3. Missing Information
      + na.rm
      + is.na
  
**Congrats! You have now finished Chapter 5!**

$~$

## Chapter 6: Environments

In this chapter we will cover:

 1. Environments
 2. Working with Environments
      + The Active Environment
      + Scoping Rules
      + Assignment
      + Evaluation
      + Closures
      
To finalize the functions `deal()` and `shuffle()` we need to consider how R uses environments.

R saves every object inside of an environment, a list-like object that resembles a computer folder. Each environment is connected to a hierarchy of environments. You can see R's environment system with:

```{r}
install.packages("pryr")
library(pryr)
parenvs(all = TRUE)
```

The environments are ranked from "lowest" to "highest". The highest environment being `R_EmptyEnv` and lowest environment being `R_GlobalEnv`.

Although seemingly like a folder directory hierarchy there are two main differences:

 + R's environments are stored in RAM
 + R's environments are not searchable down the environment "tree"

#### Environment Helper Functions

Look at an environment:

```{r}
as.environment("package:stats")
```

Which shows the path too.

Three environments come with their own accessor functions:

```{r}
globalenv()
baseenv()
emptyenv()
```

Look up an environment's parent with:

```{r}
parent.env(globalenv())
```

Notice that the highest environment has no parent:

```{r}
parent.env(emptyenv())
```

You can view objects saved in an environment with:

```{r}
ls(emptyenv())
ls(globalenv())
```

Load the deck again to check:

```{r}
deck <- read.csv("deck.csv")
ls(globalenv())
```

And learn more about the environment structure:

```{r}
ls.str(globalenv())
```

The base environment has many objects:

```{r}
ls.str(baseenv())
```

RStudio's environment pane displays all the objects in your global environment.

You can use the `$` syntax to access the `deck` object from the global environment accessor:

```{r}
head(globalenv()$deck, 3)
```

You can also use the `assign()` function to save an object into an environment:

```{r}
assign("new", "Hello Global", envir = globalenv())
globalenv()$new
```

Assign works similar to <-.

#### The Active Environment

Check the active environment using:

```{r}
environment()
```

This is usual unless you are running a function. Any object you create at the command line will be saved in the global environment. Think of it as your user work space.

**Scoping Rules** are used to look up objects:

 1. R Looks for objects in the current environment - global environment for command line
 2. If not found, R looks up and up the parent environment tree

Remember, functions are objects and will be searched for like anything else
in the environment tree.

**Assignment**: Assigning an object a new value will overwrite it:

```{r}
new
new <- "Hello Active"
new
```

But when functions are called, *R creates a new active environment to evaluate the function in* because temporary objects within the function could otherwise overwrite global environment objects.

**Evaluation**: Temporary environments for function runs are called *run time environments*. Let's write a function to show what environments look like:

```{r}
show_env <- function(){
  list(ran.in = environment(),
       parent = parent.env(environment()),
       objects = ls.str(environment()))
}
```

`show_env()` is a function, so when it is called, R creates a run time environment. The results of `show_env()` will therefore show the details of the run time environment:

```{r}
show_env()
```

Notice R created a new environment `0x7f8bf05382b0`to run `show_env()`. It contained no objects, and its parent environment was the global environment. If you run it again, you'll see it creates a new but otherwise identical temporary environment:

```{r}
show_env()
```












