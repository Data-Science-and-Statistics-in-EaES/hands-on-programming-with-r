---
title: "Completed Exercises from Hands-On Programming with R"
author: "Gavin McNicol"
date: "1/22/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

$~$

## Introduction

### Acknowledgement

These are the completed exercises for the 10 chapters of *Hands-On Programming with R* authored by Garrett Grolemund. The full text is freely available at <https://rstudio-education.github.io/hopr>.

### Purpose

Although the online version of the textbook includes most of the solutions, they are embedded within all the other material. I therefore created this set of completed exercises  to:

 - **provide a concise template of completed solutions for the coding exercises**
 
But also, to:

 - **practice using pulling and pushing to Github repositories**
 - **gain experience with RMarkdown syntax**

### Getting Started with R

Although I highly recommend the use of [RStudio Cloud](https://rstudio.cloud/), the textbook *Hands-On Programming with R* also features a handy [Appendix](https://rstudio-education.github.io/hopr/starting.html) to guide you through setting up R and RStudio IDE (Integrated Development Environment) on your local computer. 

$~$

## Chapter 1: The Very Basics

In this chapter we will cover:

 - Objects
 - Functions
 - Sampling with and without replacement
 - Writing your own functions
 - Function arguments
 - Extracting a function in RStudio

### Objects

You can assign an object a name and a value as follows

```{r}
# use <- to assign the value of 1 to the object 'a'
a <- 1
# then test it
a + 2
# the output of the expression evaluated (a + 2) is displayed in the box above
# note the use of the pound sign (#) at the start of a line lets me annotate the code
```

```{r}
# create an object, die, that is a sequence of numbers from 1 to 6, using ':'
die <- 1:6
die
```

R also understands capitalization in object names:

```{r}
Name <- 1
name <- 0

name + 1
```

R overwrites previous information without asking permission:

```{r}
my_number <- 1
my_number

my_number <- 999
my_number
```

Look at all the objects you have created using `ls()`:
```{r}
ls()
```

You can clear all your work space objects using (remove the # first)

```{r}
# rm(list=ls())
```


You can do all sorts of math with die (a sequence of numeric integers)

```{r}
die - 1
die / 2
die * die
```

When you multiply two vectors of unequal length, R will repeat the shorter vector to match the long vector (known as 'vector recycling')

```{r}
die + 1:2
```


But it will produce an error when the longer objeect is not a multiple of the shorter object

```{r}
die + 1:4
```

You can also do matrix multiplication

```{r}
die %*% die # inner
die %o% die # outer
```

### Functions

To use a function, just write the name of the function and then the data you want to operate on in the parentheses:

```{r}
round(3.1415)
factorial(3)
```

The data you pass the function is called the function's **argument**. The argument can be:

```{r}
mean(1:6) # raw data
mean(die) # an R object
round(mean(die)) # of even the result of another function
```

You can "roll" the dice using the sample function, with arguments `x` (vector/data) and `size` (number of elements to sample):

```{r}
sample(x = 1:6, size = 2)
```

Roll your die by setting x to `die` and sample 1 number from it:

```{r}
sample(x = die, size = 1)

```

Roll it again:

```{r}
sample(x = die, size = 1)
```

R doesn't require arguments to be named, for example:

```{r}
sample(die, 1)
```

And if you use the wrong argument names, you will get an error:

```{r}
# round(3.1415, corners = 2) # running this without the # sign will cause an error
# this is because the function round() does not use the argument 'corners'
```

You can look up the function's arguments with `args`:

```{r}
args(round) 
# the output shows that the digits argument has a default value of zero, which rounds to the nearest integer
```

You can change the default value by assigning a new value to the digits argument:

```{r}
round(3.1415, digits = 2)
```

If you do not write argument names (which is recommended for any arguments after the first 2) then R matches values using the order:

```{r}
sample(die, 1) # here, R automatically matches the value 1 to the argument 'size'
```

If you name all your arguments, R doesn't care if you enter them in the non-standard order:

```{r}
sample(size = 1, x = die) 
```

### Sample with replacement

By setting the argument size to 2, we can almost simulate the rolling of a pair of dice:

```{r}
sample(die, size = 2)
```

*Almost* like two dice, because if you repeat it many times, you will see that it never selects the same number twice:
```{r}
sample(die, size = 2) 
sample(die, size = 2)  
sample(die, size = 2)  
```

In other words, it samples *without* replacement.

We need to sample *with* replacement, using the argument `replace = TRUE`:

```{r}
sample(die, size = 2, replace = TRUE) 
```

Sampling with replacement is an easy way to create independent random samples.

**Congratulations, you can now simulate rolling a pair of dice!**

You can also add up the result of your simulated dice throw if you save the output to the object `dice`, then use the function `sum()` on dice:

```{r}
dice <- sample(die, size = 2, replace = TRUE)
dice
sum(dice)
```

Confirm that calling dice won't rerun `sample(die, 2, replace = TRUE)`:

```{r}
dice
dice # it gives the same result as originally output 
```

However, you *can* create an object that will re-roll the dice whenever you call it. In R, these are called **Functions**.

### Writing your own functions

We will write a function `roll()`, that will return the sum of rolling two dice:

```{r}
roll <- function() { # this line contains the function name (roll) and the parentheses contain the argument (here, there are none)
  die <- 1:6
  dice <- sample(die, size = 2, replace = TRUE)
  sum(dice) # these three lines within the pair of braces contain the function's body of code. The indentations are only for clarity.
}
```

R returns the last line of the body of code within the function, so make sure the final line of code returns a value:

```{r}
roll()
```

For instance, these lines of code as the final line will return a value:

```{r}
dice
1 + 1
sqrt(2)
```

But these lines will not:

```{r}
dice <- sample(die, size = 2, replace = TRUE)
two <- 1 + 1
a <- sqrt(2)
```

### Arguments

What would happen if we changed our `roll()` function to this?

```{r}
# roll2 <- function() {
#   dice <- sample(bones, size = 2, replace = TRUE)
#   sum(dice)
# }
# 
# roll2()
```

If you remove the # signs, it produces an error because the object `bones` cannot be found by the function.

To supply `bones`, put the object name bones as an argument in the parentheses that follow the function:

```{r}
roll2 <- function(bones) {
  dice <- sample(bones, size = 2, replace = TRUE)
  sum(dice)
}
```

Now `roll2()` will work as long as you provide a value or values for `bones` each time you call it:

```{r}
roll2(bones = 1:6)
```

Because there is only one argument, `bones`, we do not need to name it for R to match the values:

```{r}
roll2(1:6)
```

roll2() will still give an error if you do not supply `bones` at all. You can prevent this by assigning a default value when writing the function:

```{r}
roll2 <- function(bones = 1:6) {
  dice <- sample(bones, size = 2, replace = TRUE)
  sum(dice)
}
```

```{r}
roll2()
```

You can give your functions as many arguments as you like, just list their names, separated by a comma.

### Extract Function in RStudio

If you are working in the script window of RStudio you can create a function from lines of code using the drop-down menu option **Code > Extract Function**.

Test it out with the three lines of code from the body of code in our `roll()` function:

```{r}
die <- 1:6
dice <- sample(die, size = 2, replace = TRUE)
sum(dice)
```

After you've done it, your code should update to look like this:

```{r}
roll <- function() {
  die <- 1:6
  dice <- sample(die, size = 2, replace = TRUE)
  sum(dice)
}
```

You should now have a familiarity with:

 - Objects
 - Functions
 - Sampling with and without replacement
 - Writing your own functions
 - Function arguments
 - Extracting a function in RStudio
 
**Great work, you've finished Chapter 1!**

$~$

## Chapter 2: Packages and Help Pages

In this chapter we will cover:

 - Installing a package
 - Loading a package from your library of packages
 - Plotting using the function `qplot` from the `ggplot` package
 - Using help pages

### Packages

Packages are collections of functions and objects made by professors, programmers, statisticians, and other R users.

We will try using the `qplot` function which comes from the *ggplot2* package, a popular package for making graphs.

First, install the package with the following function:

```{r}
install.packages("ggplot2")
```

`qplot` won't work without loading it:

```{r}
# qplot
# will give an error if you remove the # sign
```

To load an installed package use:

```{r}
library("ggplot2")
```

And look at `qplot`:

```{r}
qplot
```

`qplot` makes "quick plots". Let's test it out by defining some x and y values:

```{r}
x <- c(-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1)
x
```

```{r}
y <- c(x^3)
y
```

```{r}
qplot(x, y)
```

Notice how R matches the order of values in the vector `x` with the order of values in vector `y`? 

This is known as *element-wise execution*.

We can also make a histogram by just providing one vector of values:

```{r}
x <- c(1, 2, 2, 2, 3, 3)
qplot(x, binwidth = 1)
```

The notation for describing this histogram intervals looks like: `[1, 2)`
The hard bracket `[` means the first number is included in the interval.
The parenthesis `)` means the last number is *not* included.

For example, in the histogram above, there are three values in the interval `[2, 3)`.

Let's try another example:

```{r}
x2 <- c(1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4)
qplot(x2, binwidth = 1)
```

And another:

```{r}
x3 <- c(0, 1, 1, 2, 2, 2, 3, 3, 4)
qplot(x3, binwidth = 1)
```

You can use a histogram to display visually how common different values of `x` are.

Let's try visualizing many the *replicated* output of `roll()` (many dice rolls):

```{r}
replicate(3, 1 + 1)
```

```{r}
rolls <- replicate(10, roll())
qplot(rolls, binwidth = 1)
```

To get a better sense of the long term  pattern, let's replicate it 10,000 times:

```{r}
rolls <- replicate(10000, roll())
qplot(rolls, binwidth = 1)
```

The histogram shows that the dice behaves predictably when replicated many times. The more likely values occur more frequently (e.g., 6, 7, and 8)


### Help Pages

Use a question mark `?` before a function name to open the help page:

```{r}
?sqrt
?log10
?sample
```

The help page has several sections:

 - *Description*
 - *Usage*
 - *Arguments*
 - *Details*
 - *Value*
 - *See Also*
 - *Examples*
 
You can also search by keyword if you forget a function name:"

```{r}
??log
```

Let's look at the `sample` help page:

```{r}
?sample
```

You'll have to copy and paste `?sample` into your RStudio console window, or run it from the script window.

