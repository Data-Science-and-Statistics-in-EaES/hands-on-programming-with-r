---
title: "Completed Exercises from Hands-On Programming with R"
author: "Gavin McNicol"
date: "1/22/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

### Acknowledgement

These are the completed exercises for the 10 chapters of *Hands-On Programming with R* authored by Garrett Grolemund. The full text is freely available at <https://rstudio-education.github.io/hopr>.

### Purpose

Although the online version of the textbook includes most of the solutions, they are embedded within all the other material. I therefore created this set of completed exercises  to:

 - **provide a concise template of completed solutions for the coding exercises**
 
But also, to:

 - **practice using pulling and pushing to Github repositories**
 - **gain experience with RMarkdown syntax**

### Getting Started with R

Although I highly recommend the use of [RStudio Cloud](https://rstudio.cloud/), the textbook *Hands-On Programming with R* also features a handy [Appendix](https://rstudio-education.github.io/hopr/starting.html) to guide you through setting up R and RStudio IDE (Integrated Development Environment) on your local computer.

## Chapter 1

### Objects

You can assign an object a name and a value as follows

```{r}
# use <- to assign the value of 1 to the object 'a'
a <- 1
# then test it
a + 2
# the output of the expression evaluated (a + 2) is displayed in the box above
# note the use of the pound sign (#) at the start of a line lets me annotate the code
```

```{r}
# create an object 'die that is a sequence of numbers from 1 to 6, using ':'
die <- 1:6
die
```

R also understands capitalization in object names

```{r}
Name <- 1
name <- 0

name + 1
```

R overwrites previous information without asking permission

```{r}
my_number <- 1
my_number

my_number <- 999
my_number
```

Look at all the objects you have created using 'ls()'
```{r}
ls()
```

You can clear all your work space objects using (remove the # first)

```{r}
# rm(list=ls())
```


You can do all sorts of math with die (a sequence of numeric integers)

```{r}
die - 1
die / 2
die * die
```

When you multiply two vectors of unequal length, R will repeat the shorter vector to match the long vector (known as 'vector recycling')

```{r}
die + 1:2
```


But it will produce an error when the longer objeect is not a multiple of the shorter object

```{r}
die + 1:4
```

You can also do matrix multiplication

```{r}
die %*% die # inner
die %o% die # outer
```

### Functions

To use a function, just write the name of the function and then the data you want to operate on in the parentheses:

```{r}
round(3.1415)
factorial(3)
```

The data you pass the function is called the function's 'argument'. The argument can be:

```{r}
mean(1:6) # raw data
mean(die) # an R object
round(mean(die)) # of even the result of another function
```

You can "roll" the dice using the sample function, with arguments 'x' (vector/data) and 'size' (number of elements to sample):

```{r}
sample(x = 1:6, size = 2)
```

Roll your die by setting x to 'die' and sample 1 number from it:

```{r}
sample(x = die, size = 1)

```

Roll it again:

```{r}
sample(x = die, size = 1)
```

R doesn't require arguments to be named, for example:

```{r}
sample(die, 1)
```

And if you use the wrong argument names, you will get an error:

```{r}
# round(3.1415, corners = 2) # running this without the # sign will cause an error
# this is because the function round() does not use the argument 'corners'
```

You can look up the function's arguments with 'args':

```{r}
args(round) 
# the output shows that the digits argument has a default value of zero, which rounds to the nearest integer
```

You can change the default value by assigning a new value to the digits argument:

```{r}
round(3.1415, digits = 2)
```

If you do not write argument names (which is recommended for any arguments after the first 2) then R matches values using the order:

```{r}
sample(die, 1) # here, R automatically matches the value 1 to the argument 'size'
```

If you name all your arguments, R doesn't care if you enter them in the non-standard order:

```{r}
sample(size = 1, x = die) 
```

### Sample with replacement

By setting the argument size to 2, we can almost simulate the rolling of a pair of dice:

```{r}
sample(die, size = 2)
```

*Almost* like two dice, because if you repeat it many times, you will see that it never selects the same number twice:
```{r}
sample(die, size = 2) 
sample(die, size = 2)  
sample(die, size = 2)  
```

In other words, it samples *without* replacement.

We need to sample *with* replacement, using the argument replace = TRUE:

```{r}
sample(die, size = 2, replace = TRUE) 
```

Sampling with replacement is an easy way to create independent random samples.


### Congratulations, you can now simulate rolling a pair of dice!

You can also add up the result of your simulated dice throw if you save the output to the object 'dice', then use the function sum() on dice:

```{r}
dice <- sample(die, size = 2, replace = TRUE)
dice
sum(dice)
```

Confirm that calling dice won't rerun sample(die, 2, replace = TRUE):

```{r}
dice
dice # it gives the same result as originally output 
```

However, you *can* create an object that will re-roll the dice whenever you call it. In R, these are called **Functions**.

### Writing your own functions

### Arguments

### Extract Function in RStudio
