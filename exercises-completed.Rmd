---
title: "Completed Exercises from Hands-On Programming with R"
author: "Gavin McNicol"
date: "1/22/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

$~$

## Introduction

### Acknowledgement

These are the completed exercises for the 10 chapters of *Hands-On Programming with R* authored by Garrett Grolemund. The full text is freely available at <https://rstudio-education.github.io/hopr>.

### Purpose

Although the online version of the textbook includes most of the solutions, they are embedded within all the other material. I therefore created this set of completed exercises  to:

 - **provide a concise template of completed solutions for the coding exercises**
 
But also, to:

 - **practice using pulling and pushing to Github repositories**
 - **gain experience with RMarkdown syntax**

### Getting Started with R

Although I highly recommend the use of [RStudio Cloud](https://rstudio.cloud/), the textbook *Hands-On Programming with R* also features a handy [Appendix](https://rstudio-education.github.io/hopr/starting.html) to guide you through setting up R and RStudio IDE (Integrated Development Environment) on your local computer. 

$~$

## Chapter 1: The Very Basics

In this chapter we will cover:

 - Objects
 - Functions
 - Sampling with and without replacement
 - Writing your own functions
 - Function arguments
 - Extracting a function in RStudio

### Objects

You can assign an object a name and a value as follows

```{r}
# use <- to assign the value of 1 to the object 'a'
a <- 1
# then test it
a + 2
# the output of the expression evaluated (a + 2) is displayed in the box above
# note the use of the pound sign (#) at the start of a line lets me annotate the code
```

```{r}
# create an object, die, that is a sequence of numbers from 1 to 6, using ':'
die <- 1:6
die
```

R also understands capitalization in object names:

```{r}
Name <- 1
name <- 0

name + 1
```

R overwrites previous information without asking permission:

```{r}
my_number <- 1
my_number

my_number <- 999
my_number
```

Look at all the objects you have created using `ls()`:
```{r}
ls()
```

You can clear all your work space objects using (remove the # first)

```{r}
# rm(list=ls())
```


You can do all sorts of math with die (a sequence of numeric integers)

```{r}
die - 1
die / 2
die * die
```

When you multiply two vectors of unequal length, R will repeat the shorter vector to match the long vector (known as 'vector recycling')

```{r}
die + 1:2
```


But it will produce an error when the longer objeect is not a multiple of the shorter object

```{r}
die + 1:4
```

You can also do matrix multiplication

```{r}
die %*% die # inner
die %o% die # outer
```

### Functions

To use a function, just write the name of the function and then the data you want to operate on in the parentheses:

```{r}
round(3.1415)
factorial(3)
```

The data you pass the function is called the function's **argument**. The argument can be:

```{r}
mean(1:6) # raw data
mean(die) # an R object
round(mean(die)) # of even the result of another function
```

You can "roll" the dice using the sample function, with arguments `x` (vector/data) and `size` (number of elements to sample):

```{r}
sample(x = 1:6, size = 2)
```

Roll your die by setting x to `die` and sample 1 number from it:

```{r}
sample(x = die, size = 1)

```

Roll it again:

```{r}
sample(x = die, size = 1)
```

R doesn't require arguments to be named, for example:

```{r}
sample(die, 1)
```

And if you use the wrong argument names, you will get an error:

```{r}
# round(3.1415, corners = 2) # running this without the # sign will cause an error
# this is because the function round() does not use the argument 'corners'
```

You can look up the function's arguments with `args`:

```{r}
args(round) 
# the output shows that the digits argument has a default value of zero, which rounds to the nearest integer
```

You can change the default value by assigning a new value to the digits argument:

```{r}
round(3.1415, digits = 2)
```

If you do not write argument names (which is recommended for any arguments after the first 2) then R matches values using the order:

```{r}
sample(die, 1) # here, R automatically matches the value 1 to the argument 'size'
```

If you name all your arguments, R doesn't care if you enter them in the non-standard order:

```{r}
sample(size = 1, x = die) 
```

### Sample with replacement

By setting the argument size to 2, we can almost simulate the rolling of a pair of dice:

```{r}
sample(die, size = 2)
```

*Almost* like two dice, because if you repeat it many times, you will see that it never selects the same number twice:
```{r}
sample(die, size = 2) 
sample(die, size = 2)  
sample(die, size = 2)  
```

In other words, it samples *without* replacement.

We need to sample *with* replacement, using the argument `replace = TRUE`:

```{r}
sample(die, size = 2, replace = TRUE) 
```

Sampling with replacement is an easy way to create independent random samples.

**Congratulations, you can now simulate rolling a pair of dice!**

You can also add up the result of your simulated dice throw if you save the output to the object `dice`, then use the function `sum()` on dice:

```{r}
dice <- sample(die, size = 2, replace = TRUE)
dice
sum(dice)
```

Confirm that calling dice won't rerun `sample(die, 2, replace = TRUE)`:

```{r}
dice
dice # it gives the same result as originally output 
```

However, you *can* create an object that will re-roll the dice whenever you call it. In R, these are called **Functions**.

### Writing your own functions

We will write a function `roll()`, that will return the sum of rolling two dice:

```{r}
roll <- function() { # this line contains the function name (roll) and the parentheses contain the argument (here, there are none)
  die <- 1:6
  dice <- sample(die, size = 2, replace = TRUE)
  sum(dice) # these three lines within the pair of braces contain the function's body of code. The indentations are only for clarity.
}
```

R returns the last line of the body of code within the function, so make sure the final line of code returns a value:

```{r}
roll()
```

For instance, these lines of code as the final line will return a value:

```{r}
dice
1 + 1
sqrt(2)
```

But these lines will not:

```{r}
dice <- sample(die, size = 2, replace = TRUE)
two <- 1 + 1
a <- sqrt(2)
```

### Arguments

What would happen if we changed our `roll()` function to this?

```{r}
# roll2 <- function() {
#   dice <- sample(bones, size = 2, replace = TRUE)
#   sum(dice)
# }
# 
# roll2()
```

If you remove the # signs, it produces an error because the object `bones` cannot be found by the function.

To supply `bones`, put the object name bones as an argument in the parentheses that follow the function:

```{r}
roll2 <- function(bones) {
  dice <- sample(bones, size = 2, replace = TRUE)
  sum(dice)
}
```

Now `roll2()` will work as long as you provide a value or values for `bones` each time you call it:

```{r}
roll2(bones = 1:6)
```

Because there is only one argument, `bones`, we do not need to name it for R to match the values:

```{r}
roll2(1:6)
```

roll2() will still give an error if you do not supply `bones` at all. You can prevent this by assigning a default value when writing the function:

```{r}
roll2 <- function(bones = 1:6) {
  dice <- sample(bones, size = 2, replace = TRUE)
  sum(dice)
}
```

```{r}
roll2()
```

You can give your functions as many arguments as you like, just list their names, separated by a comma.

### Extract Function in RStudio

If you are working in the script window of RStudio you can create a function from lines of code using the drop-down menu option **Code > Extract Function**.

Test it out with the three lines of code from the body of code in our `roll()` function:

```{r}
die <- 1:6
dice <- sample(die, size = 2, replace = TRUE)
sum(dice)
```

After you've done it, your code should update to look like this:

```{r}
roll <- function() {
  die <- 1:6
  dice <- sample(die, size = 2, replace = TRUE)
  sum(dice)
}
```

You should now have a familiarity with:

 - Objects
 - Functions
 - Sampling with and without replacement
 - Writing your own functions
 - Function arguments
 - Extracting a function in RStudio
 
**Great work, you've finished Chapter 1!**

$~$

## Chapter 2: Packages and Help Pages

In this chapter we will cover:

 - Installing a package
 - Loading a package from your library of packages
 - Plotting using the function `qplot` from the `ggplot` package
 - Using help pages

### Packages

Packages are collections of functions and objects made by professors, programmers, statisticians, and other R users.

We will try using the `qplot` function which comes from the *ggplot2* package, a popular package for making graphs.

First, install the package with the following function:

```{r}
# install.packages("ggplot2")
```

`qplot` won't work without loading it:

```{r}
# qplot
# will give an error if you remove the # sign
```

To load an installed package use:

```{r}
library("ggplot2")
```

And look at `qplot`:

```{r}
qplot
```

`qplot` makes "quick plots". Let's test it out by defining some x and y values:

```{r}
x <- c(-1, -0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8, 1)
x
```

```{r}
y <- c(x^3)
y
```

```{r}
qplot(x, y)
```

Notice how R matches the order of values in the vector `x` with the order of values in vector `y`? 

This is known as *element-wise execution*.

We can also make a histogram by just providing one vector of values:

```{r}
x <- c(1, 2, 2, 2, 3, 3)
qplot(x, binwidth = 1)
```

The notation for describing this histogram intervals looks like: `[1, 2)`
The hard bracket `[` means the first number is included in the interval.
The parenthesis `)` means the last number is *not* included.

For example, in the histogram above, there are three values in the interval `[2, 3)`.

Let's try another example:

```{r}
x2 <- c(1, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 4)
qplot(x2, binwidth = 1)
```

And another:

```{r}
x3 <- c(0, 1, 1, 2, 2, 2, 3, 3, 4)
qplot(x3, binwidth = 1)
```

You can use a histogram to display visually how common different values of `x` are.

Let's try visualizing many the *replicated* output of `roll()` (many dice rolls):

```{r}
replicate(3, 1 + 1)
```

```{r}
rolls <- replicate(10, roll())
qplot(rolls, binwidth = 1)
```

To get a better sense of the long term  pattern, let's replicate it 10,000 times:

```{r}
rolls <- replicate(10000, roll())
qplot(rolls, binwidth = 1)
```

The histogram shows that the dice behaves predictably when replicated many times. The more likely values occur more frequently (e.g., 6, 7, and 8)


### Help Pages

Use a question mark `?` before a function name to open the help page:

```{r}
?sqrt
?log10
?sample
```

The help page has several sections:

 - *Description*
 - *Usage*
 - *Arguments*
 - *Details*
 - *Value*
 - *See Also*
 - *Examples*
 
You can also search by keyword if you forget a function name:"

```{r}
??log
```

Let's look at the `sample` help page:

```{r}
?sample
```

You'll have to copy and paste `?sample` into your RStudio console window, or run it from the script window.

Notice `prob`:

|   `A vector of probability weights for obtaining the elemtents of the vector being sampled.`

And Details has more information:
|   `The optional prob argument can be used to give a vector of weights for obtaining the elements of the vector being sampled. They need not sum to one, but they should be nonnegative and not all zero`

Re-write the `roll` function to roll a pair of weighted dice:

```{r}
roll <- function() {
  die <- 1:6
  dice <- sample(die, size = 2, replace = T, 
                 prob = c(rep(1/8, 5), 3/8))
  sum(dice)
}
```

Rerun the code chunk above, and then visualize the long term behavior of your dice:

```{r}
rolls <- replicate(10000, roll())
qplot(rolls, binwidth = 1)
```

Notice that after changing the `prob` vector to make 6 more common, the distribution of dice roll outcomes is now skewed.

You should now have a familiarity with:

 - Installing a package
 - Loading a package from your library of packages
 - Plotting using the function `qplot` from the `ggplot` package
 - Using help pages
 
**Great job, you've finished Chapter 2!**

$~$

## Chapter 3: R Objects

In this chapter we will cover:

 1. Objects
     + Atomic Vectors
     + Doubles
     + Integers
     + Characters
     + Logicals
     + Complex and Raw
 2. Attributes 
     + Names
     + Dim
 3. Matrices
 4. Arrays
 5. Class
     + Dates and Times
     + Factors
 6. Coercion
 7. Lists
 8. Data Frames
 9. Loading Data
 10. Saving Data

### Objects
#### Atomic Vectors

Create an atomic vector by grouping values with c (concatenate)

```{r}
die <- c(1, 2, 3, 4, 5, 6)
die
is.vector(die)
```

Vectors can be of just one value

```{r}
five <- 5
is.vector(five)
```

There are 6 types of atomic vectors in R:

 1. *Doubles* are the default for numbers and are the computer science term for numerics:

```{r}
typeof(die)
```


 2. *Integers* store numbers without decimal points. Adding an L after a numeric value creates an integer:
 
```{r}
int <- c(-1L, 2L, 4L)
int
typeof(int)
```

By default, integer numbers saved without the L will be saved as double.

Double values are accurate to about 16 significant digits. This rounding is normally negligible, but can create *floating-point errors* when rounding effects add up.

 3. *Character vectors* store small pieces of text:
 
```{r}
text <- c("Hello", "World")
text
typeof(text)
```

The individual elements of a character vector are known as strings. Can you tell the difference between a character string and a number?

```{r}
typeof(1)
typeof("1")
typeof("one")
```

Be careful, you can confuse R objects with strings, for example:

```{r}
x <- "x"
x
```

 4. *Logicals* are TRUE, FALSE, T, and F are R's version of logical (Boolean) data:
 
```{r}
logic <- c(TRUE, TRUE, FALSE)
logic
typeof(logic)
typeof(T)
```
 
 5. *Complex*. It is unlikely you will ever use these last two vector types but... for a complex vector, add an imaginary term to a number, with i:
 
```{r}
comp <- c(1 + 1i, 1 + 2i, 1 + 3i)
comp
typeof(comp)
```
 
 6. *Raw* vectors store raw bytes of data. A simple empty raw vector of length n can be made with:
 
```{r}
raw(3)
typeof(raw(3))
```

**Exercise**: What sort of vector will you use to store the face names of cards in a royal flush? ( i.e. "ace", "king", "queen", "jack", "ten )

```{r}
hand <- c("ace", "king", "queen", "jack", "ten")
hand
typeof(hand)
```

#### Attributes

You can build a more sophisticated objects vector from an atomic vector by giving it *attributes* and assigning a *class*.

An *attribute* is a piece of information you can attach to atomic vectors (or any R object). Normally, R will ignore this information, unless you ask to look for it

```{r}
attributes(die)
```

R uses NULL to represent an empty object.

*Names*, *dimensions* (*dim*), and *classes* are the most common attributes.

*Names*

```{r}
names(die)
names(die) <- c("one", "two", "three", "four", "five", "six")
names(die)
attributes(die)
```

Now die has the names attribute.

Names will be displayed above the object when you look at it:

```{r}
die
```


However they won't affect the values of the vector:

```{r}
die + 1
names(die) <- c("uno", "dos", "tres", "cuatro", "cinco", "seis")
die
```

To remove names, set it to NULL:

```{r}
names(die) <- NULL
```

*Dimensions*
You can transform an atomic vector into an n-dimensional array with dim:

```{r}
dim(die)
```

Transform it into a (2 row x 3 column) array:

```{r}
dim(die) <- c(2, 3)
die
```

Now into a (3 row x 2 column) array:

```{r}
dim(die) <- c(3, 2)
die    
```

Now into a (1 row x 2 column x 3 slice) hypercube (a 3 dimensional structure):

```{r}
dim(die) <- c(1, 2, 3)
die
```

Two notes on dim

 * R will always use the first value of dim for the rows, and second for columns
 * R will always fill the array by columns (all rows in column 1 first, and so on

*Matrices* store two-dimensional arrays. A matrix will organize your vector of values into a matrix with the specified number of rows:

```{r}
m <- matrix(die, nrow = 2)
m
```

To fill by row (rather than default by column):

```{r}
m <- matrix(die, nrow = 2, byrow = TRUE)
m
```

More customization is possible, remember to check the help page with:

```{r}
?matrix
```

*Arrays* create an n-dimensional array, for example a hypercube in 4, 5, or n dimensions:

```{r}
ar <- array(c(11:14, 21:24, 31:34), dim = c(2, 2, 3))
ar
```

**Exercise**: Create a 5 x 2 matrix for a royal flush of spades. (Remember the hand object created earlier)

```{r}
hand1 <- c(hand, "spades", "spades", "spades", "spades", "spades")

matrix(hand1, nrow = 5)
matrix(hand1 , ncol = 2)
dim(hand1) <- c(5, 2)
hand1
```

Notice that all three of these options for arranging the array dimensions work.

